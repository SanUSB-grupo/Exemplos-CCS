CCS PCH C Compiler, Version 4.084, 29964               27-abr-14 20:26

               Filename: C:\Users\Sandro\Dropbox\Public\121007SanUSBOrig\ExemploseBibliotecasCCS\i2c_RTC_eeprom.lst

               ROM used: 3740 bytes (11%)
                         Largest free fragment is 24928
               RAM used: 100 (5%) at main() level
                         129 (6%) worst case
               Stack:    4 worst case (3 in main + 1 for interrupts)

*
1000:  GOTO   1A68
*
1008:  MOVWF  05
100A:  MOVFF  FD8,06
100E:  MOVFF  FE0,07
1012:  MOVLB  0
1014:  MOVFF  FE9,0D
1018:  MOVFF  FEA,08
101C:  MOVFF  FE1,09
1020:  MOVFF  FE2,0A
1024:  MOVFF  FD9,0B
1028:  MOVFF  FDA,0C
102C:  MOVFF  FF3,14
1030:  MOVFF  FF4,15
1034:  MOVFF  FFA,16
1038:  MOVFF  00,0F
103C:  MOVFF  01,10
1040:  MOVFF  02,11
1044:  MOVFF  03,12
1048:  MOVFF  04,13
104C:  BTFSS  F9D.5
104E:  GOTO   1058
1052:  BTFSC  F9E.5
1054:  GOTO   10EC
1058:  MOVFF  0F,00
105C:  MOVFF  10,01
1060:  MOVFF  11,02
1064:  MOVFF  12,03
1068:  MOVFF  13,04
106C:  MOVFF  0D,FE9
1070:  MOVFF  08,FEA
1074:  BSF    08.7
1076:  MOVFF  09,FE1
107A:  MOVFF  0A,FE2
107E:  MOVFF  0B,FD9
1082:  MOVFF  0C,FDA
1086:  MOVFF  14,FF3
108A:  MOVFF  15,FF4
108E:  MOVFF  16,FFA
1092:  MOVF   05,W
1094:  MOVFF  07,FE0
1098:  MOVFF  06,FD8
109C:  RETFIE 0
.................... #include "SanUSBi2c.h" // Firmware para configuração serial (via bluettoh) e leitura por SOFTWARE de EEPROM i2c e do relógio DS1307 (BCD) 
.................... ///////////////////http://br.groups.yahoo.com/group/GrupoSanUSB///////////////// 
.................... // Firmware para configuração serial (via bluetooth) e leitura por SOFTWARE de EEPROM i2c e do relógio DS1307 (BCD) 
.................... #include <18F4550.h> //This library 18F4550.h is valid for the whole family USB PIC18Fx5xx 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #byte OSCCON=0XFD3 
.................... #byte SPBRGH=0xFB0 
.................... #byte SPBRG=0xFAF 
.................... #byte BAUDCON= 0xFB8 
.................... #byte TXSTA=0xFAC 
.................... #byte RCSTA=0xFAB 
.................... #BYTE RCREG=0xFAE 
.................... #BYTE TXREG=0xFAD 
.................... #BYTE PIE1=0xF9D 
.................... #BIT TRMT=TXSTA.1 
.................... #BIT RCIE=PIE1.5 
.................... #bit BRG16=BAUDCON.3 
.................... #BYTE INTCON=0xFF2 
....................  
.................... #define key_HC05  pin_b2 
....................  
....................  
.................... #device ADC=10 
.................... #fuses HSPLL,PLL5, USBDIV,CPUDIV1,VREGEN,NOWDT,NOPROTECT,NOLVP,NODEBUG 
.................... #use delay(clock=4000000)// USB standard frequency (cpu and timers 12 MIPS = 4/48MHz) 
*
1318:  CLRF   FEA
131A:  MOVLW  78
131C:  MOVWF  FE9
131E:  MOVF   FEF,W
1320:  BZ    133E
1322:  MOVLW  01
1324:  MOVWF  01
1326:  CLRF   00
1328:  DECFSZ 00,F
132A:  BRA    1328
132C:  DECFSZ 01,F
132E:  BRA    1326
1330:  MOVLW  4A
1332:  MOVWF  00
1334:  DECFSZ 00,F
1336:  BRA    1334
1338:  BRA    133A
133A:  DECFSZ FEF,F
133C:  BRA    1322
133E:  RETLW  00
....................  
.................... //SanUSB program memory allocation 
.................... #define CODE_START 0x1000 
.................... #build(reset=CODE_START, interrupt=CODE_START+0x08) 
.................... #org 0, CODE_START-1 {} 
....................  
.................... unsigned char REG=0x0f, EEADR=0x33, R=0x0a, REGad=0xdf; 
.................... unsigned char k=0; 
.................... short int c=0, flagb=0; 
.................... unsigned char  comand[30]; 
....................  
.................... const unsigned char icg[] = {130,168,86,132,130,170,136,106,0}; 
.................... const unsigned char icm[] = {130,168,86,156,130,154,138,166,194,220,170,166,132,98,0}; 
.................... const unsigned char icgs[] = {130,168,86,170,130,164,168,122,98,114,100,96,96,88,96,88,96,26,20,0};  //98,114,100//102,112,104//114,108 
.................... const unsigned char icms[] = {130,168,86,156,130,154,138,122,166,194,220,170,166,132,98,106,26,20,0}; 
.................... const unsigned char icrs[] = {130,168,86,164,138,166,138,168,26,20,0}; 
.................... const unsigned char atc1[] =  {130,168,26,20,0}; 
....................  
.................... void clock_int_4MHz(void) 
.................... { 
....................  OSCCON=0B01100110; //with dual clock -> cpu and timers  #use delay(clock=4000000) 
*
1214:  MOVLW  66
1216:  MOVWF  FD3
....................  while(read_eeprom(0xfd)); 
1218:  MOVFF  FF2,68
121C:  BCF    FF2.7
121E:  MOVLW  FD
1220:  MOVWF  FA9
1222:  BCF    FA6.6
1224:  BCF    FA6.7
1226:  BSF    FA6.0
1228:  MOVF   FA8,W
122A:  BTFSC  x68.7
122C:  BSF    FF2.7
122E:  XORLW  00
1230:  BNZ   1218
....................                            } 
1232:  GOTO   1AA8 (RETURN)
....................  
.................... void swputc(char c) 
.................... { 
.................... while (!TRMT); 
*
16D2:  BTFSS  FAC.1
16D4:  BRA    16D2
.................... TXREG=REG+c; 
16D6:  MOVF   x73,W
16D8:  ADDWF  18,W
16DA:  MOVWF  FAD
.................... } 
16DC:  RETLW  00
....................  
.................... void sputc(unsigned char c) 
.................... { 
.................... while (!TRMT); 
*
1340:  BTFSS  FAC.1
1342:  BRA    1340
....................     TXREG=(c>>BRG16)+REG; 
1344:  MOVLW  00
1346:  BTFSC  FB8.3
1348:  MOVLW  01
134A:  MOVWF  01
134C:  MOVFF  7D,00
1350:  MOVF   01,F
1352:  BZ    135C
1354:  BCF    FD8.0
1356:  RRCF   00,F
1358:  DECFSZ 01,F
135A:  BRA    1354
135C:  MOVF   00,W
135E:  ADDWF  18,W
1360:  MOVWF  FAD
.................... } 
1362:  RETLW  00
....................  
.................... void sendsw( char st[]){ 
....................            for(k=0;st[k]!='\0';k++) {swputc(st[k]);} 
*
1A36:  CLRF   1C
1A38:  CLRF   03
1A3A:  MOVF   1C,W
1A3C:  ADDWF  x6B,W
1A3E:  MOVWF  FE9
1A40:  MOVF   x6C,W
1A42:  ADDWFC 03,W
1A44:  MOVWF  FEA
1A46:  MOVF   FEF,F
1A48:  BZ    1A66
1A4A:  CLRF   03
1A4C:  MOVF   1C,W
1A4E:  ADDWF  x6B,W
1A50:  MOVWF  FE9
1A52:  MOVF   x6C,W
1A54:  ADDWFC 03,W
1A56:  MOVWF  FEA
1A58:  MOVFF  FEF,6D
1A5C:  MOVFF  6D,73
1A60:  RCALL  16D2
1A62:  INCF   1C,F
1A64:  BRA    1A38
....................                               } 
1A66:  RETLW  00
....................  
.................... void sends(unsigned char st[]){ 
....................     for(k=0;st[k]!='\0';k++) {sputc(st[k]);} 
*
1364:  CLRF   1C
1366:  CLRF   03
1368:  MOVF   1C,W
136A:  ADDWF  x7A,W
136C:  MOVWF  FE9
136E:  MOVF   x7B,W
1370:  ADDWFC 03,W
1372:  MOVWF  FEA
1374:  MOVF   FEF,F
1376:  BZ    1394
1378:  CLRF   03
137A:  MOVF   1C,W
137C:  ADDWF  x7A,W
137E:  MOVWF  FE9
1380:  MOVF   x7B,W
1382:  ADDWFC 03,W
1384:  MOVWF  FEA
1386:  MOVFF  FEF,7C
138A:  MOVFF  7C,7D
138E:  RCALL  1340
1390:  INCF   1C,F
1392:  BRA    1366
.................... } 
1394:  RETLW  00
....................  
.................... void sendnum(unsigned int16 sannum) 
.................... { 
....................    if(sannum > 9999) { 
*
17AE:  MOVF   x6B,W
17B0:  SUBLW  26
17B2:  BC    180E
17B4:  XORLW  FF
17B6:  BNZ   17BE
17B8:  MOVF   x6A,W
17BA:  SUBLW  0F
17BC:  BC    180E
....................         swputc(((sannum / 10000) % 10)+REG+'0');  
17BE:  MOVFF  6B,6F
17C2:  MOVFF  6A,6E
17C6:  MOVLW  27
17C8:  MOVWF  x71
17CA:  MOVLW  10
17CC:  MOVWF  x70
17CE:  RCALL  176C
17D0:  MOVFF  02,6D
17D4:  MOVFF  01,6C
17D8:  MOVFF  02,6F
17DC:  MOVFF  01,6E
17E0:  CLRF   x71
17E2:  MOVLW  0A
17E4:  MOVWF  x70
17E6:  RCALL  176C
17E8:  MOVFF  00,6D
17EC:  MOVFF  03,6E
17F0:  MOVF   18,W
17F2:  ADDWF  00,W
17F4:  MOVWF  x6F
17F6:  MOVLW  00
17F8:  ADDWFC 03,W
17FA:  MOVWF  x70
17FC:  MOVLW  30
17FE:  ADDWF  x6F,W
1800:  MOVWF  x71
1802:  MOVLW  00
1804:  ADDWFC x70,W
1806:  MOVWF  x72
1808:  MOVFF  71,73
180C:  RCALL  16D2
....................     } 
....................    if(sannum > 999) { 
180E:  MOVF   x6B,W
1810:  SUBLW  02
1812:  BC    186E
1814:  XORLW  FF
1816:  BNZ   181E
1818:  MOVF   x6A,W
181A:  SUBLW  E7
181C:  BC    186E
....................         swputc(((sannum / 1000) % 10)+REG+'0'); 
181E:  MOVFF  6B,6F
1822:  MOVFF  6A,6E
1826:  MOVLW  03
1828:  MOVWF  x71
182A:  MOVLW  E8
182C:  MOVWF  x70
182E:  RCALL  176C
1830:  MOVFF  02,6D
1834:  MOVFF  01,6C
1838:  MOVFF  02,6F
183C:  MOVFF  01,6E
1840:  CLRF   x71
1842:  MOVLW  0A
1844:  MOVWF  x70
1846:  RCALL  176C
1848:  MOVFF  00,6D
184C:  MOVFF  03,6E
1850:  MOVF   18,W
1852:  ADDWF  00,W
1854:  MOVWF  x6F
1856:  MOVLW  00
1858:  ADDWFC 03,W
185A:  MOVWF  x70
185C:  MOVLW  30
185E:  ADDWF  x6F,W
1860:  MOVWF  x71
1862:  MOVLW  00
1864:  ADDWFC x70,W
1866:  MOVWF  x72
1868:  MOVFF  71,73
186C:  RCALL  16D2
....................     } 
....................     if(sannum > 99) { 
186E:  MOVF   x6B,F
1870:  BNZ   1878
1872:  MOVF   x6A,W
1874:  SUBLW  63
1876:  BC    18C6
....................         swputc(((sannum / 100) % 10)+REG+'0'); 
1878:  MOVFF  6B,6F
187C:  MOVFF  6A,6E
1880:  CLRF   x71
1882:  MOVLW  64
1884:  MOVWF  x70
1886:  RCALL  176C
1888:  MOVFF  02,6D
188C:  MOVFF  01,6C
1890:  MOVFF  02,6F
1894:  MOVFF  01,6E
1898:  CLRF   x71
189A:  MOVLW  0A
189C:  MOVWF  x70
189E:  RCALL  176C
18A0:  MOVFF  00,6D
18A4:  MOVFF  03,6E
18A8:  MOVF   18,W
18AA:  ADDWF  00,W
18AC:  MOVWF  x6F
18AE:  MOVLW  00
18B0:  ADDWFC 03,W
18B2:  MOVWF  x70
18B4:  MOVLW  30
18B6:  ADDWF  x6F,W
18B8:  MOVWF  x71
18BA:  MOVLW  00
18BC:  ADDWFC x70,W
18BE:  MOVWF  x72
18C0:  MOVFF  71,73
18C4:  RCALL  16D2
....................     } 
....................     if(sannum > 9) { 
18C6:  MOVF   x6B,F
18C8:  BNZ   18D0
18CA:  MOVF   x6A,W
18CC:  SUBLW  09
18CE:  BC    191E
....................         swputc(((sannum / 10) % 10)+REG+'0'); 
18D0:  MOVFF  6B,6F
18D4:  MOVFF  6A,6E
18D8:  CLRF   x71
18DA:  MOVLW  0A
18DC:  MOVWF  x70
18DE:  RCALL  176C
18E0:  MOVFF  02,6D
18E4:  MOVFF  01,6C
18E8:  MOVFF  02,6F
18EC:  MOVFF  01,6E
18F0:  CLRF   x71
18F2:  MOVLW  0A
18F4:  MOVWF  x70
18F6:  RCALL  176C
18F8:  MOVFF  00,6D
18FC:  MOVFF  03,6E
1900:  MOVF   18,W
1902:  ADDWF  00,W
1904:  MOVWF  x6F
1906:  MOVLW  00
1908:  ADDWFC 03,W
190A:  MOVWF  x70
190C:  MOVLW  30
190E:  ADDWF  x6F,W
1910:  MOVWF  x71
1912:  MOVLW  00
1914:  ADDWFC x70,W
1916:  MOVWF  x72
1918:  MOVFF  71,73
191C:  RCALL  16D2
....................     } 
....................     swputc((sannum % 10)+REG+'0') ; 
191E:  MOVFF  6B,6F
1922:  MOVFF  6A,6E
1926:  CLRF   x71
1928:  MOVLW  0A
192A:  MOVWF  x70
192C:  RCALL  176C
192E:  MOVFF  00,6C
1932:  MOVFF  03,6D
1936:  MOVF   18,W
1938:  ADDWF  00,W
193A:  MOVWF  x6E
193C:  MOVLW  00
193E:  ADDWFC 03,W
1940:  MOVWF  x6F
1942:  MOVLW  30
1944:  ADDWF  x6E,W
1946:  MOVWF  x70
1948:  MOVLW  00
194A:  ADDWFC x6F,W
194C:  MOVWF  x71
194E:  MOVFF  70,73
1952:  RCALL  16D2
.................... } 
1954:  RETLW  00
....................  
....................  
.................... void ATC() 
.................... { 
....................    output_toggle(pin_b7); delay_ms(500); 
....................    sends(atc1); 
....................    output_toggle(pin_b7); delay_ms(1000); 
.................... } 
.................... void resetBT() 
.................... { 
....................    output_toggle(pin_b7); delay_ms(1000); 
....................    sends(icrs); 
....................    output_toggle(pin_b7); delay_ms(1000); 
.................... } 
....................  
.................... void modoAttention() 
.................... { 
....................    output_high(key_HC05); 
....................      SPBRGH = 0x02; SPBRG=0x70; ATC(); 
....................    if(flagb==0){ 
....................     SPBRGH = 0x01; SPBRG=0x37; ATC(); 
....................                 } 
....................    if(flagb==0){ 
....................     SPBRGH = 0x04; SPBRG=0xE1; ATC(); 
....................                } 
.................... } 
....................  
.................... void modoNormal() 
.................... { 
....................    output_low(key_HC05); 
....................    resetBT(); 
....................    if(icgs[0b00001000]==0b01110010){SPBRGH = 0x04; SPBRG=0xE1;} 
....................    if(icgs[0b00001000]==0b01100010){SPBRGH = 0x02; SPBRG=0x70;} 
....................    if(icgs[0b00001000]==0b01100110){SPBRGH = 0x01; SPBRG=0x37;} 
.................... } 
....................  
.................... void configBR6()  
.................... { 
....................    modoAttention(); 
....................    flagb=0;sends(icgs); 
....................    output_toggle(pin_b7); delay_ms(1000); 
....................    sends(icms); 
....................    output_toggle(pin_b7); delay_ms(1000); 
....................    modoNormal(); 
.................... } 
.................... void i2i_ini(void){ 
....................   SPBRG=0x67;delay_ms(100);sends(icg);delay_ms(500);sputc(26);delay_ms(500); 
*
1396:  MOVLW  67
1398:  MOVWF  FAF
139A:  MOVLW  64
139C:  MOVWF  x78
139E:  RCALL  1318
13A0:  CLRF   FEA
13A2:  MOVLW  68
13A4:  MOVWF  FE9
13A6:  MOVFF  FF2,77
13AA:  BCF    FF2.7
13AC:  MOVLW  09
13AE:  MOVWF  01
13B0:  CLRF   FF7
13B2:  MOVLW  00
13B4:  RCALL  109E
13B6:  TBLRD*-
13B8:  TBLRD*+
13BA:  MOVFF  FF5,FEE
13BE:  DECFSZ 01,F
13C0:  BRA    13B8
13C2:  BTFSC  x77.7
13C4:  BSF    FF2.7
13C6:  CLRF   x7B
13C8:  MOVLW  68
13CA:  MOVWF  x7A
13CC:  RCALL  1364
13CE:  MOVLW  02
13D0:  MOVWF  x77
13D2:  MOVLW  FA
13D4:  MOVWF  x78
13D6:  RCALL  1318
13D8:  DECFSZ x77,F
13DA:  BRA    13D2
13DC:  MOVLW  1A
13DE:  MOVWF  x7D
13E0:  RCALL  1340
13E2:  MOVLW  02
13E4:  MOVWF  x77
13E6:  MOVLW  FA
13E8:  MOVWF  x78
13EA:  RCALL  1318
13EC:  DECFSZ x77,F
13EE:  BRA    13E6
....................   SPBRG=0x33;delay_ms(100);sends(icg);delay_ms(500);sputc(26);delay_ms(500); 
13F0:  MOVLW  33
13F2:  MOVWF  FAF
13F4:  MOVLW  64
13F6:  MOVWF  x78
13F8:  RCALL  1318
13FA:  CLRF   FEA
13FC:  MOVLW  68
13FE:  MOVWF  FE9
1400:  MOVFF  FF2,77
1404:  BCF    FF2.7
1406:  MOVLW  09
1408:  MOVWF  01
140A:  CLRF   FF7
140C:  MOVLW  00
140E:  RCALL  109E
1410:  TBLRD*-
1412:  TBLRD*+
1414:  MOVFF  FF5,FEE
1418:  DECFSZ 01,F
141A:  BRA    1412
141C:  BTFSC  x77.7
141E:  BSF    FF2.7
1420:  CLRF   x7B
1422:  MOVLW  68
1424:  MOVWF  x7A
1426:  RCALL  1364
1428:  MOVLW  02
142A:  MOVWF  x77
142C:  MOVLW  FA
142E:  MOVWF  x78
1430:  RCALL  1318
1432:  DECFSZ x77,F
1434:  BRA    142C
1436:  MOVLW  1A
1438:  MOVWF  x7D
143A:  RCALL  1340
143C:  MOVLW  02
143E:  MOVWF  x77
1440:  MOVLW  FA
1442:  MOVWF  x78
1444:  RCALL  1318
1446:  DECFSZ x77,F
1448:  BRA    1440
....................   SPBRG=0x19;delay_ms(100);sends(icg);delay_ms(500);sputc(26);delay_ms(500); 
144A:  MOVLW  19
144C:  MOVWF  FAF
144E:  MOVLW  64
1450:  MOVWF  x78
1452:  RCALL  1318
1454:  CLRF   FEA
1456:  MOVLW  68
1458:  MOVWF  FE9
145A:  MOVFF  FF2,77
145E:  BCF    FF2.7
1460:  MOVLW  09
1462:  MOVWF  01
1464:  CLRF   FF7
1466:  MOVLW  00
1468:  RCALL  109E
146A:  TBLRD*-
146C:  TBLRD*+
146E:  MOVFF  FF5,FEE
1472:  DECFSZ 01,F
1474:  BRA    146C
1476:  BTFSC  x77.7
1478:  BSF    FF2.7
147A:  CLRF   x7B
147C:  MOVLW  68
147E:  MOVWF  x7A
1480:  RCALL  1364
1482:  MOVLW  02
1484:  MOVWF  x77
1486:  MOVLW  FA
1488:  MOVWF  x78
148A:  RCALL  1318
148C:  DECFSZ x77,F
148E:  BRA    1486
1490:  MOVLW  1A
1492:  MOVWF  x7D
1494:  RCALL  1340
1496:  MOVLW  02
1498:  MOVWF  x77
149A:  MOVLW  FA
149C:  MOVWF  x78
149E:  RCALL  1318
14A0:  DECFSZ x77,F
14A2:  BRA    149A
....................   if(icg[0b00000111]==108){SPBRG=0x19;}if(icg[0b00000111]==106){SPBRG=0x33;} 
14A4:  MOVLW  33
14A6:  MOVWF  FAF
....................   if(icg[0b00000111]==104){SPBRG=0x67;} 
....................   delay_ms(500);sends(icm);delay_ms(500);sputc(26);delay_ms(500); 
14A8:  MOVLW  02
14AA:  MOVWF  x77
14AC:  MOVLW  FA
14AE:  MOVWF  x78
14B0:  RCALL  1318
14B2:  DECFSZ x77,F
14B4:  BRA    14AC
14B6:  CLRF   FEA
14B8:  MOVLW  68
14BA:  MOVWF  FE9
14BC:  MOVFF  FF2,77
14C0:  BCF    FF2.7
14C2:  MOVLW  0F
14C4:  MOVWF  01
14C6:  CLRF   FF7
14C8:  MOVLW  00
14CA:  RCALL  10C2
14CC:  TBLRD*-
14CE:  TBLRD*+
14D0:  MOVFF  FF5,FEE
14D4:  DECFSZ 01,F
14D6:  BRA    14CE
14D8:  BTFSC  x77.7
14DA:  BSF    FF2.7
14DC:  CLRF   x7B
14DE:  MOVLW  68
14E0:  MOVWF  x7A
14E2:  RCALL  1364
14E4:  MOVLW  02
14E6:  MOVWF  x77
14E8:  MOVLW  FA
14EA:  MOVWF  x78
14EC:  RCALL  1318
14EE:  DECFSZ x77,F
14F0:  BRA    14E8
14F2:  MOVLW  1A
14F4:  MOVWF  x7D
14F6:  RCALL  1340
14F8:  MOVLW  02
14FA:  MOVWF  x77
14FC:  MOVLW  FA
14FE:  MOVWF  x78
1500:  RCALL  1318
1502:  DECFSZ x77,F
1504:  BRA    14FC
....................   
....................                   } 
1506:  GOTO   1ADA (RETURN)
....................      
.................... /*************************************************************************************/ 
.................... void taxa_serial(unsigned long taxa) {  
.................... unsigned long baud_sanusb;  
....................      set_tris_c(0b10111111);  
*
12B0:  MOVLW  BF
12B2:  MOVWF  F94
....................      TXSTA = 0x24;        
12B4:  MOVLW  24
12B6:  MOVWF  FAC
....................      RCSTA = 0x90;        
12B8:  MOVLW  90
12BA:  MOVWF  FAB
....................      BAUDCON = 0x08;      
12BC:  MOVLW  08
12BE:  MOVWF  FB8
....................  
....................   baud_sanusb = ((4000000/4)/ taxa) - 1;  
12C0:  CLRF   x6F
12C2:  MOVLW  0F
12C4:  MOVWF  x6E
12C6:  MOVLW  42
12C8:  MOVWF  x6D
12CA:  MOVLW  40
12CC:  MOVWF  x6C
12CE:  CLRF   x73
12D0:  CLRF   x72
12D2:  MOVFF  69,71
12D6:  MOVFF  68,70
12DA:  RCALL  1236
12DC:  MOVLW  01
12DE:  SUBWF  00,W
12E0:  MOVWF  x6A
12E2:  MOVLW  00
12E4:  SUBWFB 01,W
12E6:  MOVWF  x6B
....................   SPBRGH = (unsigned char)(baud_sanusb >> 8); 
12E8:  MOVF   x6B,W
12EA:  MOVWF  FB0
....................   SPBRG = (unsigned char)baud_sanusb; 
12EC:  MOVFF  6A,FAF
....................   REGad=R*(EEADR>>1)+3; 
12F0:  BCF    FD8.0
12F2:  RRCF   19,W
12F4:  MULWF  1A
12F6:  MOVF   FF3,W
12F8:  ADDLW  03
12FA:  MOVWF  1B
....................   REG=read_eeprom(REGad); 
12FC:  MOVFF  FF2,6C
1300:  BCF    FF2.7
1302:  MOVFF  1B,FA9
1306:  BCF    FA6.6
1308:  BCF    FA6.7
130A:  BSF    FA6.0
130C:  MOVF   FA8,W
130E:  BTFSC  x6C.7
1310:  BSF    FF2.7
1312:  MOVWF  18
....................                                    } 
1314:  GOTO   1AB4 (RETURN)
....................                                     
....................                                     
....................  
....................  
....................  
.................... #include "i2c_sanusb.h"//Biblioteca de funcoes I2C com a placa SanUSB. RB0(SDA) e RB1(SCL) 
.................... /**********http://br.groups.yahoo.com/group/GrupoSanUSB/*************************/ 
.................... // Definições dos pinos de comunicação I2C SanUSB 
....................    #ifndef scl 
....................    #define scl  pin_b1             // pino de clock 
....................    #define sda  pin_b0              // pino de dados 
....................  
....................    #define EEPROM_SIZE 32768       // tamanho em bytes da memória EEPROM 
....................    #endif 
....................  
....................    #define seta_scl   output_float(scl)      // seta o pino scl 
....................    #define apaga_scl  output_low(scl)      // apaga o pino scl 
....................    #define seta_sda   output_float(sda)      // seta o pino sda 
....................    #define apaga_sda  output_low(sda)      // apaga o pino sda 
....................  
.................... // RAM do RTC DS1307 
.................... #define seg  0x00 
.................... #define min  0x01 
.................... #define hora 0x02 
.................... #define dia  0x04 
.................... #define mes  0x05 
.................... #define ano  0x06 
.................... /******************************************************************************/ 
.................... //SUB-ROTINAS DA COMUNICAÇÃO I2C 
....................  
....................    void I2C_start(void) 
....................    // coloca o barramento na condição de start 
....................    { 
....................       apaga_scl;     // coloca a linha de clock em nível 0 
*
155A:  BCF    F93.1
155C:  BCF    F8A.1
....................       delay_us(5); 
155E:  BRA    1560
1560:  BRA    1562
1562:  NOP   
....................       seta_sda;   // coloca a linha de dados em alta impedância (1) 
1564:  BSF    F93.0
....................       delay_us(5); 
1566:  BRA    1568
1568:  BRA    156A
156A:  NOP   
....................       seta_scl;   // coloca a linha de clock em alta impedância (1) 
156C:  BSF    F93.1
....................       delay_us(5); 
156E:  BRA    1570
1570:  BRA    1572
1572:  NOP   
....................       apaga_sda;   // coloca a linha de dados em nível 0 
1574:  BCF    F93.0
1576:  BCF    F8A.0
....................       delay_us(5); 
1578:  BRA    157A
157A:  BRA    157C
157C:  NOP   
....................       apaga_scl;   // coloca a linha de clock em nível 0 
157E:  BCF    F93.1
1580:  BCF    F8A.1
....................       delay_us(5); 
1582:  BRA    1584
1584:  BRA    1586
1586:  NOP   
....................    } 
1588:  RETLW  00
....................  
....................    void I2C_stop(void) 
....................    // coloca o barramento na condição de stop 
....................    { 
....................       apaga_scl;   // coloca a linha de clock em nível 0 
*
15EA:  BCF    F93.1
15EC:  BCF    F8A.1
....................       delay_us(5); 
15EE:  BRA    15F0
15F0:  BRA    15F2
15F2:  NOP   
....................       apaga_sda;   // coloca a linha de dados em nível 0 
15F4:  BCF    F93.0
15F6:  BCF    F8A.0
....................       delay_us(5); 
15F8:  BRA    15FA
15FA:  BRA    15FC
15FC:  NOP   
....................       seta_scl;   // coloca a linha de clock em alta impedância (1) 
15FE:  BSF    F93.1
....................       delay_us(5); 
1600:  BRA    1602
1602:  BRA    1604
1604:  NOP   
....................       seta_sda;   // coloca a linha de dados em alta impedância (1) 
1606:  BSF    F93.0
....................       delay_us(5); 
1608:  BRA    160A
160A:  BRA    160C
160C:  NOP   
....................    } 
160E:  RETLW  00
....................  
....................    void i2c_ack() 
....................    // coloca sinal de reconhecimento (ack) no barramento 
....................    { 
....................       apaga_sda;   // coloca a linha de dados em nível 0 
....................       delay_us(5); 
....................       seta_scl;   // coloca a linha de clock em alta impedância (1) 
....................       delay_us(5); 
....................       apaga_scl;   // coloca a linha de clock em nível 0 
....................       delay_us(5); 
....................       seta_sda;   // coloca a linha de dados em alta impedância (1) 
....................       delay_us(5); 
....................    } 
....................  
....................    void i2c_nack() 
....................    // coloca sinal de não reconhecimento (nack) no barramento 
....................    { 
....................       seta_sda;   // coloca a linha de dados em alta impedância (1) 
*
168A:  BSF    F93.0
....................       delay_us(5); 
168C:  BRA    168E
168E:  BRA    1690
1690:  NOP   
....................       seta_scl;   // coloca a linha de clock em alta impedância (1) 
1692:  BSF    F93.1
....................       delay_us(5); 
1694:  BRA    1696
1696:  BRA    1698
1698:  NOP   
....................       apaga_scl;   // coloca a linha de clock em nível 0 
169A:  BCF    F93.1
169C:  BCF    F8A.1
....................       delay_us(5); 
169E:  BRA    16A0
16A0:  BRA    16A2
16A2:  NOP   
....................    } 
16A4:  RETLW  00
....................  
....................    boolean i2c_le_ack() 
....................    // efetua a leitura do sinal de ack/nack 
....................    { 
....................       boolean estado; 
....................       seta_sda;    // coloca a linha de dados em alta impedância (1) 
*
15BE:  BSF    F93.0
....................       delay_us(5); 
15C0:  BRA    15C2
15C2:  BRA    15C4
15C4:  NOP   
....................       seta_scl;   // coloca a linha de clock em alta impedância (1) 
15C6:  BSF    F93.1
....................       delay_us(5); 
15C8:  BRA    15CA
15CA:  BRA    15CC
15CC:  NOP   
....................       estado = input(sda);   // lê o bit (ack/nack) 
15CE:  BSF    F93.0
15D0:  BCF    x77.0
15D2:  BTFSC  F81.0
15D4:  BSF    x77.0
....................       apaga_scl;   // coloca a linha de clock em nível 0 
15D6:  BCF    F93.1
15D8:  BCF    F8A.1
....................       delay_us(5); 
15DA:  BRA    15DC
15DC:  BRA    15DE
15DE:  NOP   
....................       return estado; 
15E0:  MOVLW  00
15E2:  BTFSC  x77.0
15E4:  MOVLW  01
15E6:  MOVWF  01
....................    } 
15E8:  RETLW  00
....................  
....................    void I2C_escreve_byte(unsigned char dado) 
....................    { 
....................    // envia um byte pelo barramento I2C 
....................       int conta=8; 
*
158A:  MOVLW  08
158C:  MOVWF  x7A
....................       apaga_scl;      // coloca SCL em 0 
158E:  BCF    F93.1
1590:  BCF    F8A.1
....................       while (conta) 
....................       { 
1592:  MOVF   x7A,F
1594:  BZ    15BA
....................          // envia primeiro o MSB 
....................          if (shift_left(&dado,1,0)) seta_sda; else apaga_sda; 
1596:  BCF    FD8.0
1598:  RLCF   x79,F
159A:  BNC   15A0
159C:  BSF    F93.0
159E:  BRA    15A4
15A0:  BCF    F93.0
15A2:  BCF    F8A.0
....................          // dá um pulso em scl 
....................          seta_scl; 
15A4:  BSF    F93.1
....................          delay_us(5); 
15A6:  BRA    15A8
15A8:  BRA    15AA
15AA:  NOP   
....................          conta--; 
15AC:  DECF   x7A,F
....................          apaga_scl; 
15AE:  BCF    F93.1
15B0:  BCF    F8A.1
....................          delay_us(5); 
15B2:  BRA    15B4
15B4:  BRA    15B6
15B6:  NOP   
....................       } 
15B8:  BRA    1592
....................       // ativa sda 
....................       seta_sda; 
15BA:  BSF    F93.0
....................    } 
15BC:  RETLW  00
....................  
....................    unsigned char I2C_le_byte() 
....................    // recebe um byte pelo barramento I2C 
....................    { 
....................       unsigned char bytelido, conta = 8; 
*
1650:  MOVLW  08
1652:  MOVWF  x78
....................       bytelido = 0; 
1654:  CLRF   x77
....................       apaga_scl; 
1656:  BCF    F93.1
1658:  BCF    F8A.1
....................       delay_us(5); 
165A:  BRA    165C
165C:  BRA    165E
165E:  NOP   
....................       seta_sda; 
1660:  BSF    F93.0
....................       delay_us(5); 
1662:  BRA    1664
1664:  BRA    1666
1666:  NOP   
....................       while (conta) 
....................       { 
1668:  MOVF   x78,F
166A:  BZ    1684
....................          // ativa scl 
....................          seta_scl; 
166C:  BSF    F93.1
....................          // lê o bit em sda, deslocando em bytelido 
....................          shift_left(&bytelido,1,input(sda)); 
166E:  BSF    F93.0
1670:  BTFSC  F81.0
1672:  BRA    1678
1674:  BCF    FD8.0
1676:  BRA    167A
1678:  BSF    FD8.0
167A:  RLCF   x77,F
....................          conta--; 
167C:  DECF   x78,F
....................          // desativa scl 
....................          apaga_scl; 
167E:  BCF    F93.1
1680:  BCF    F8A.1
....................       } 
1682:  BRA    1668
....................       return bytelido; 
1684:  MOVFF  77,01
....................    } 
1688:  RETLW  00
....................  
....................    void escreve_eeprom(byte dispositivo, long endereco, byte dado) 
....................    // Escreve um dado em um endereço do dispositivo 
....................    // dispositivo - é o endereço do dispositivo escravo (0 - 7) 
....................    // endereco - é o endereço da memória a ser escrito 
....................    // dado - é a informação a ser armazenada 
....................    { 
....................       if (dispositivo>7) dispositivo = 7; 
*
196C:  MOVF   x6A,W
196E:  SUBLW  07
1970:  BC    1976
1972:  MOVLW  07
1974:  MOVWF  x6A
....................       i2c_start(); 
1976:  RCALL  155A
....................       i2c_escreve_byte(0xa0 | (dispositivo << 1)); // endereça o dispositivo 
1978:  BCF    FD8.0
197A:  RLCF   x6A,W
197C:  IORLW  A0
197E:  MOVWF  x6E
1980:  MOVWF  x79
1982:  RCALL  158A
....................       i2c_le_ack(); 
1984:  RCALL  15BE
....................       i2c_escreve_byte(endereco >> 8);   // parte alta do endereço 
1986:  MOVFF  6C,6E
198A:  CLRF   x6F
198C:  MOVFF  6C,79
1990:  RCALL  158A
....................       i2c_le_ack(); 
1992:  RCALL  15BE
....................       i2c_escreve_byte(endereco);   // parte baixa do endereço 
1994:  MOVFF  6B,79
1998:  RCALL  158A
....................       i2c_le_ack(); 
199A:  RCALL  15BE
....................       i2c_escreve_byte(dado);         // dado a ser escrito 
199C:  MOVFF  6D,79
19A0:  RCALL  158A
....................       i2c_le_ack(); 
19A2:  RCALL  15BE
....................       i2c_stop(); 
19A4:  RCALL  15EA
....................       while(read_eeprom(0xfd)); 
19A6:  MOVFF  FF2,6E
19AA:  BCF    FF2.7
19AC:  MOVLW  FD
19AE:  MOVWF  FA9
19B0:  BCF    FA6.6
19B2:  BCF    FA6.7
19B4:  BSF    FA6.0
19B6:  MOVF   FA8,W
19B8:  BTFSC  x6E.7
19BA:  BSF    FF2.7
19BC:  XORLW  00
19BE:  BNZ   19A6
....................       delay_ms(10); // aguarda a programação da memória 
19C0:  MOVLW  0A
19C2:  MOVWF  x78
19C4:  RCALL  1318
....................    } 
19C6:  RETLW  00
....................  
....................    byte le_eeprom(byte dispositivo, long int endereco) 
....................    // Lê um dado de um endereço especificado no dispositivo 
....................    // dispositivo - é o endereço do dispositivo escravo (0 - 7) 
....................    // endereco - é o endereço da memória a ser escrito 
....................    { 
....................       byte dado; 
....................       if (dispositivo>7) dispositivo = 7; 
*
19E6:  MOVF   x73,W
19E8:  SUBLW  07
19EA:  BC    19F0
19EC:  MOVLW  07
19EE:  MOVWF  x73
....................       i2c_start(); 
19F0:  RCALL  155A
....................       i2c_escreve_byte(0xa0 | (dispositivo << 1)); // endereça o dispositivo 
19F2:  BCF    FD8.0
19F4:  RLCF   x73,W
19F6:  IORLW  A0
19F8:  MOVWF  x77
19FA:  MOVWF  x79
19FC:  RCALL  158A
....................       i2c_le_ack(); 
19FE:  RCALL  15BE
....................       i2c_escreve_byte((endereco >> 8));   // envia a parte alta do endereço 
1A00:  MOVFF  75,77
1A04:  CLRF   x78
1A06:  MOVFF  75,79
1A0A:  RCALL  158A
....................       i2c_le_ack(); 
1A0C:  RCALL  15BE
....................       i2c_escreve_byte(endereco);   // envia a parte baixa do endereço 
1A0E:  MOVFF  74,79
1A12:  RCALL  158A
....................       i2c_le_ack(); 
1A14:  RCALL  15BE
....................       i2c_start(); 
1A16:  RCALL  155A
....................       // envia comando de leitura 
....................       i2c_escreve_byte(0xa1 | (dispositivo << 1)); 
1A18:  BCF    FD8.0
1A1A:  RLCF   x73,W
1A1C:  IORLW  A1
1A1E:  MOVWF  x77
1A20:  MOVWF  x79
1A22:  RCALL  158A
....................       i2c_le_ack(); 
1A24:  RCALL  15BE
....................       dado = i2c_le_byte();   // lê o dado 
1A26:  RCALL  1650
1A28:  MOVFF  01,76
....................       i2c_nack(); 
1A2C:  RCALL  168A
....................       i2c_stop(); 
1A2E:  RCALL  15EA
....................       return dado; 
1A30:  MOVFF  76,01
....................    } 
1A34:  RETLW  00
.................... /******************************************************************************/ 
.................... //******************************************************************************/ 
.................... void escreve_rtc(byte enderecoram, byte dado) 
.................... // Escreve um dado em um endereço do dispositivo 
.................... // endereco - é o endereço da memória a ser escrito 
.................... // dado - é a informação a ser armazenada 
.................... { 
....................    i2c_start(); 
*
1610:  RCALL  155A
....................    i2c_escreve_byte(0xd0); 
1612:  MOVLW  D0
1614:  MOVWF  x79
1616:  RCALL  158A
....................    i2c_le_ack(); 
1618:  RCALL  15BE
....................    i2c_escreve_byte(enderecoram);   // parte baixa do endereço de 16 bits 
161A:  MOVFF  69,79
161E:  RCALL  158A
....................    i2c_le_ack(); 
1620:  RCALL  15BE
....................    i2c_escreve_byte(dado);         // dado a ser escrito 
1622:  MOVFF  6A,79
1626:  RCALL  158A
....................    i2c_le_ack(); 
1628:  RCALL  15BE
....................    i2c_stop(); 
162A:  RCALL  15EA
....................    while(read_eeprom(0xfd)); 
162C:  MOVFF  FF2,6B
1630:  BCF    FF2.7
1632:  MOVLW  FD
1634:  MOVWF  FA9
1636:  BCF    FA6.6
1638:  BCF    FA6.7
163A:  BSF    FA6.0
163C:  MOVF   FA8,W
163E:  BTFSC  x6B.7
1640:  BSF    FF2.7
1642:  XORLW  00
1644:  BNZ   162C
....................    delay_ms(10); // aguarda a programação da memória 
1646:  MOVLW  0A
1648:  MOVWF  x78
164A:  RCALL  1318
.................... } 
164C:  GOTO   1B5A (RETURN)
.................... byte le_rtc(int enderecoram) 
.................... // Lê um dado de um endereço especificado no dispositivo 
.................... // dispositivo - é o endereço do dispositivo escravo (0 - 7) 
.................... // endereco - é o endereço da memória a ser escrito 
.................... { 
....................    byte dado; 
....................    i2c_start(); 
*
16A6:  RCALL  155A
....................    i2c_escreve_byte(0xd0); // endereça o dispositivo e colocando leitura 0xd1 
16A8:  MOVLW  D0
16AA:  MOVWF  x79
16AC:  RCALL  158A
....................    i2c_le_ack(); 
16AE:  RCALL  15BE
....................    i2c_escreve_byte(enderecoram);   // envia a parte baixa do endereço 
16B0:  MOVFF  68,79
16B4:  RCALL  158A
....................    i2c_le_ack(); 
16B6:  RCALL  15BE
....................    i2c_start(); 
16B8:  RCALL  155A
....................    // envia comando de leitura 
....................    i2c_escreve_byte(0xd1); // Coloca o LSB (R\W) em estado de leitura 
16BA:  MOVLW  D1
16BC:  MOVWF  x79
16BE:  RCALL  158A
....................    i2c_le_ack(); 
16C0:  RCALL  15BE
....................    dado = i2c_le_byte();   // lê o dado 
16C2:  RCALL  1650
16C4:  MOVFF  01,69
....................    i2c_nack(); 
16C8:  RCALL  168A
....................    i2c_stop(); 
16CA:  RCALL  15EA
....................    return dado; 
16CC:  MOVFF  69,01
.................... } 
16D0:  RETLW  00
....................  
.................... void send_hex(unsigned char number) 
.................... { 
....................     unsigned char hexChar; 
....................     char i; 
....................     for(i = 0; i < 2; i++) 
*
16DE:  CLRF   x6C
16E0:  MOVF   x6C,W
16E2:  SUBLW  01
16E4:  BNC   1714
....................     { 
....................         if(i == 0) 
16E6:  MOVF   x6C,F
16E8:  BNZ   16F4
....................             hexChar = number >> 4; 
16EA:  SWAPF  x6A,W
16EC:  MOVWF  x6B
16EE:  MOVLW  0F
16F0:  ANDWF  x6B,F
....................         else 
16F2:  BRA    16FA
....................             hexChar = number & 0x0F; 
16F4:  MOVF   x6A,W
16F6:  ANDLW  0F
16F8:  MOVWF  x6B
....................         if(hexChar < 10) 
16FA:  MOVF   x6B,W
16FC:  SUBLW  09
16FE:  BNC   1706
....................             hexChar = hexChar + '0'; 
1700:  MOVLW  30
1702:  ADDWF  x6B,F
....................         else 
1704:  BRA    170A
....................             hexChar = hexChar + ('A' - 10); 
1706:  MOVLW  37
1708:  ADDWF  x6B,F
....................         swputc(hexChar); 
170A:  MOVFF  6B,73
170E:  RCALL  16D2
....................     } 
1710:  INCF   x6C,F
1712:  BRA    16E0
.................... } 
1714:  RETLW  00
....................  
.................... /************************************************************************************************ 
.................... * Conversão BCD P/ DECIMAL 
.................... ************************************************************************************************/ 
.................... unsigned char bcd_para_dec(unsigned char valorb) 
.................... { 
.................... unsigned char temp; 
.................... temp = (valorb & 0b00001111); 
.................... temp = (REG+temp) + ((valorb >> 4) * 10); 
.................... return(temp); 
.................... } 
.................... /************************************************************************************************* 
.................... * Conversão DECIMAL p/ BCD 
.................... ************************************************************************************************/ 
.................... unsigned char dec_para_bcd(unsigned char valord) 
.................... { 
.................... return((0x10*(valord/10))+(valord%10)+REG); 
*
1532:  MOVFF  68,6A
1536:  MOVLW  0A
1538:  MOVWF  x6B
153A:  RCALL  150A
153C:  MOVF   01,W
153E:  MULLW  10
1540:  MOVFF  FF3,69
1544:  MOVFF  68,6A
1548:  MOVLW  0A
154A:  MOVWF  x6B
154C:  RCALL  150A
154E:  MOVF   00,W
1550:  ADDWF  x69,W
1552:  ADDWF  18,W
1554:  MOVWF  01
.................... } 
1556:  GOTO   1B4C (RETURN)
....................  
....................  
.................... //Apostila disponível em https://dl.dropboxusercontent.com/u/101922388/ApostilaSanUSB/Apostila_SanUSB_CCS.pdf 
....................  
.................... unsigned char endereco, numquant=0; 
.................... unsigned char  comando[6], n=0; 
.................... short int flagA4=0, flagA5=0; 
.................... unsigned int32 resultado, tensao_lida16; 
....................  
.................... unsigned int16 i,j,endereco16=0, posicao=0, valorgravado; 
.................... unsigned char byte1,byte2; // 2 Partes do valor da tensao_lida16 
....................  
.................... unsigned int16 conv_dec_2bytes(unsigned int16 valor16)  
.................... {//Função auxiliar para alocar um valor de 16 bits (até 65535) em 2 bytes 
....................     byte1= valor16%256; byte2 = valor16/256; //o que for resto (%) é menos significativo 
*
1956:  MOVF   x6A,W
1958:  MOVWF  57
195A:  MOVFF  6B,58
....................     return(byte2,byte1); 
195E:  CLRF   03
1960:  MOVFF  57,01
1964:  MOVFF  03,02
.................... } 
1968:  GOTO   1CF2 (RETURN)
....................  
.................... #INT_RDA 
.................... void recepcao_serial() 
.................... {     comando[n] = RCREG;  
*
10EC:  CLRF   03
10EE:  MOVF   44,W
10F0:  ADDLW  3E
10F2:  MOVWF  FE9
10F4:  MOVLW  00
10F6:  ADDWFC 03,W
10F8:  MOVWF  FEA
10FA:  MOVFF  FAE,FEF
....................      if (comando[n]==79) {flagb=1;} 
10FE:  CLRF   03
1100:  MOVF   44,W
1102:  ADDLW  3E
1104:  MOVWF  FE9
1106:  MOVLW  00
1108:  ADDWFC 03,W
110A:  MOVWF  FEA
110C:  MOVF   FEF,W
110E:  SUBLW  4F
1110:  BTFSC  FD8.2
1112:  BSF    1D.1
....................      //////////FUNCAO 4: CONFIGURA RELÓGIO////////////////////Ex: Digitar A4H09 (Hora = 09) , A4D15 (Dia = 15). 
....................      if (comando[n]=='A'){n=0;comando[0] = 'A';} //UTILIZAR VALORES DECIMAIS EM DOIS DIGITOS. ex:06, 23, 15, etc. 
1114:  CLRF   03
1116:  MOVF   44,W
1118:  ADDLW  3E
111A:  MOVWF  FE9
111C:  MOVLW  00
111E:  ADDWFC 03,W
1120:  MOVWF  FEA
1122:  MOVF   FEF,W
1124:  SUBLW  41
1126:  BNZ   112E
1128:  CLRF   44
112A:  MOVLW  41
112C:  MOVWF  3E
....................  
....................          if ( comando[1]== '4' && comando[2]== 'H' && n==2) { endereco=2;} //Escreve o endereco das horas 
112E:  MOVF   3F,W
1130:  SUBLW  34
1132:  BNZ   1144
1134:  MOVF   40,W
1136:  SUBLW  48
1138:  BNZ   1144
113A:  MOVF   44,W
113C:  SUBLW  02
113E:  BNZ   1144
1140:  MOVLW  02
1142:  MOVWF  3C
....................          if ( comando[1]== '4' && comando[2]== 'M' && n==2) { endereco=1;} //Escreve o endereco dos minutos 
1144:  MOVF   3F,W
1146:  SUBLW  34
1148:  BNZ   115A
114A:  MOVF   40,W
114C:  SUBLW  4D
114E:  BNZ   115A
1150:  MOVF   44,W
1152:  SUBLW  02
1154:  BNZ   115A
1156:  MOVLW  01
1158:  MOVWF  3C
....................          if ( comando[1]== '4' && comando[2]== 'S' && n==2) { endereco=0;} //Escreve o endereco dos segundos 
115A:  MOVF   3F,W
115C:  SUBLW  34
115E:  BNZ   116E
1160:  MOVF   40,W
1162:  SUBLW  53
1164:  BNZ   116E
1166:  MOVF   44,W
1168:  SUBLW  02
116A:  BTFSC  FD8.2
116C:  CLRF   3C
....................          if ( comando[1]== '4' && comando[2]== 'D' && n==2) { endereco=4;} //Escreve o endereco do dia 
116E:  MOVF   3F,W
1170:  SUBLW  34
1172:  BNZ   1184
1174:  MOVF   40,W
1176:  SUBLW  44
1178:  BNZ   1184
117A:  MOVF   44,W
117C:  SUBLW  02
117E:  BNZ   1184
1180:  MOVLW  04
1182:  MOVWF  3C
....................          if ( comando[1]== '4' && comando[2]== 'N' && n==2) { endereco=5;} //Escreve o endereco do mes 
1184:  MOVF   3F,W
1186:  SUBLW  34
1188:  BNZ   119A
118A:  MOVF   40,W
118C:  SUBLW  4E
118E:  BNZ   119A
1190:  MOVF   44,W
1192:  SUBLW  02
1194:  BNZ   119A
1196:  MOVLW  05
1198:  MOVWF  3C
....................          if ( comando[1]== '4' && comando[2]== 'Y' && n==2) { endereco=6;} //Escreve o endereco do ano 
119A:  MOVF   3F,W
119C:  SUBLW  34
119E:  BNZ   11B0
11A0:  MOVF   40,W
11A2:  SUBLW  59
11A4:  BNZ   11B0
11A6:  MOVF   44,W
11A8:  SUBLW  02
11AA:  BNZ   11B0
11AC:  MOVLW  06
11AE:  MOVWF  3C
....................           
....................          if ( comando[1]== '4' && comando[3]>='0'&&comando[3]<='9'&& n==3) {numquant=(comando[3]-0x30);} 
11B0:  MOVF   3F,W
11B2:  SUBLW  34
11B4:  BNZ   11CE
11B6:  MOVF   41,W
11B8:  SUBLW  2F
11BA:  BC    11CE
11BC:  MOVF   41,W
11BE:  SUBLW  39
11C0:  BNC   11CE
11C2:  MOVF   44,W
11C4:  SUBLW  03
11C6:  BNZ   11CE
11C8:  MOVLW  30
11CA:  SUBWF  41,W
11CC:  MOVWF  3D
....................          if ( comando[1]== '4' && comando[4]>='0'&&comando[4]<='9'&& n==4) {numquant=numquant*10+(comando[4]-0x30);                                                                          
11CE:  MOVF   3F,W
11D0:  SUBLW  34
11D2:  BNZ   11F8
11D4:  MOVF   42,W
11D6:  SUBLW  2F
11D8:  BC    11F8
11DA:  MOVF   42,W
11DC:  SUBLW  39
11DE:  BNC   11F8
11E0:  MOVF   44,W
11E2:  SUBLW  04
11E4:  BNZ   11F8
11E6:  MOVF   3D,W
11E8:  MULLW  0A
11EA:  MOVFF  FF3,7F
11EE:  MOVLW  30
11F0:  SUBWF  42,W
11F2:  ADDWF  x7F,W
11F4:  MOVWF  3D
....................                                                                             flagA4=1; 
11F6:  BSF    1D.2
....................                                                                             } 
....................  
....................      //////////////////////FUNCAO 5: LÊ RELÓGIO////////////////////////////Ex: A5- Lê o relógio e o calendário 
....................          if (comando[1]== '5' && n==1){flagA5=1;} 
11F8:  MOVF   3F,W
11FA:  SUBLW  35
11FC:  BNZ   1204
11FE:  DECFSZ 44,W
1200:  BRA    1204
1202:  BSF    1D.3
....................  
....................          ++n; if(n>=5){n=0;} 
1204:  INCF   44,F
1206:  MOVF   44,W
1208:  SUBLW  04
120A:  BTFSS  FD8.0
120C:  CLRF   44
.................... } 
....................  
120E:  BCF    F9E.5
1210:  GOTO   1058
.................... void main(){ 
*
1A68:  CLRF   FF8
1A6A:  BCF    FD0.7
1A6C:  BSF    08.7
1A6E:  CLRF   FEA
1A70:  CLRF   FE9
1A72:  MOVF   FC1,W
1A74:  ANDLW  C0
1A76:  IORLW  0F
1A78:  MOVWF  FC1
1A7A:  MOVLW  07
1A7C:  MOVWF  FB4
1A7E:  MOVLW  0F
1A80:  MOVWF  18
1A82:  MOVLW  33
1A84:  MOVWF  19
1A86:  MOVLW  0A
1A88:  MOVWF  1A
1A8A:  MOVLW  DF
1A8C:  MOVWF  1B
1A8E:  CLRF   1C
1A90:  BCF    1D.0
1A92:  BCF    1D.1
1A94:  CLRF   3D
1A96:  CLRF   44
1A98:  BCF    1D.2
1A9A:  BCF    1D.3
1A9C:  CLRF   51
1A9E:  CLRF   52
1AA0:  CLRF   53
1AA2:  CLRF   54
....................     clock_int_4MHz(); 
1AA4:  GOTO   1214
....................     taxa_serial(9600); 
1AA8:  MOVLW  25
1AAA:  MOVWF  x69
1AAC:  MOVLW  80
1AAE:  MOVWF  x68
1AB0:  GOTO   12B0
....................     enable_interrupts(GLOBAL); 
1AB4:  MOVLW  C0
1AB6:  IORWF  FF2,F
....................     enable_interrupts(INT_RDA); 
1AB8:  BSF    F9D.5
....................     setup_adc_ports(AN0);  //Habilita entradas analógicas - A0 
1ABA:  MOVF   FC1,W
1ABC:  ANDLW  C0
1ABE:  IORLW  0E
1AC0:  MOVWF  FC1
....................     setup_adc(ADC_CLOCK_INTERNAL); 
1AC2:  BSF    FC0.0
1AC4:  BSF    FC0.1
1AC6:  BSF    FC0.2
1AC8:  BSF    FC0.7
1ACA:  BSF    FC2.0
....................     set_adc_channel(0); 
1ACC:  MOVLW  00
1ACE:  MOVWF  01
1AD0:  MOVF   FC2,W
1AD2:  ANDLW  C3
1AD4:  IORWF  01,W
1AD6:  MOVWF  FC2
....................     i2i_ini(); 
1AD8:  BRA    1396
....................  
....................    
....................   delay_ms(500);sends(icm);delay_ms(500);sputc(26);delay_ms(500);n=0;   
1ADA:  MOVLW  02
1ADC:  MOVWF  x68
1ADE:  MOVLW  FA
1AE0:  MOVWF  x78
1AE2:  RCALL  1318
1AE4:  DECFSZ x68,F
1AE6:  BRA    1ADE
1AE8:  CLRF   FEA
1AEA:  MOVLW  59
1AEC:  MOVWF  FE9
1AEE:  MOVFF  FF2,68
1AF2:  BCF    FF2.7
1AF4:  MOVLW  0F
1AF6:  MOVWF  01
1AF8:  CLRF   FF7
1AFA:  MOVLW  00
1AFC:  CALL   10C2
1B00:  TBLRD*-
1B02:  TBLRD*+
1B04:  MOVFF  FF5,FEE
1B08:  DECFSZ 01,F
1B0A:  BRA    1B02
1B0C:  BTFSC  x68.7
1B0E:  BSF    FF2.7
1B10:  CLRF   x7B
1B12:  MOVLW  59
1B14:  MOVWF  x7A
1B16:  RCALL  1364
1B18:  MOVLW  02
1B1A:  MOVWF  x68
1B1C:  MOVLW  FA
1B1E:  MOVWF  x78
1B20:  CALL   1318
1B24:  DECFSZ x68,F
1B26:  BRA    1B1C
1B28:  MOVLW  1A
1B2A:  MOVWF  x7D
1B2C:  RCALL  1340
1B2E:  MOVLW  02
1B30:  MOVWF  x68
1B32:  MOVLW  FA
1B34:  MOVWF  x78
1B36:  CALL   1318
1B3A:  DECFSZ x68,F
1B3C:  BRA    1B32
1B3E:  CLRF   44
....................     while(true){ 
....................        
....................         if (flagA4){ flagA4=0; //Comandos A4 para Configurar o RTC 
1B40:  BTFSS  1D.2
1B42:  BRA    1BD6
1B44:  BCF    1D.2
....................                 escreve_rtc(endereco, dec_para_bcd(numquant)); //Escrever em BCD no RTC 
1B46:  MOVFF  3D,68
1B4A:  BRA    1532
1B4C:  MOVFF  01,68
1B50:  MOVFF  3C,69
1B54:  MOVFF  01,6A
1B58:  BRA    1610
....................                 send_hex(le_rtc(hora)); swputc (':');     //Envia resultado via serial por bluetooth ou qualquer outro modem. 
1B5A:  MOVLW  02
1B5C:  MOVWF  x68
1B5E:  RCALL  16A6
1B60:  MOVFF  01,68
1B64:  MOVFF  01,6A
1B68:  RCALL  16DE
1B6A:  MOVLW  3A
1B6C:  MOVWF  x73
1B6E:  RCALL  16D2
....................                 send_hex(le_rtc(min));  swputc (':');     //Exemplo de resposta: 18:49:37 19/04/14 
1B70:  MOVLW  01
1B72:  MOVWF  x68
1B74:  RCALL  16A6
1B76:  MOVFF  01,68
1B7A:  MOVFF  01,6A
1B7E:  RCALL  16DE
1B80:  MOVLW  3A
1B82:  MOVWF  x73
1B84:  RCALL  16D2
....................                 send_hex(le_rtc(seg));  swputc (' '); 
1B86:  CLRF   x68
1B88:  RCALL  16A6
1B8A:  MOVFF  01,68
1B8E:  MOVFF  01,6A
1B92:  RCALL  16DE
1B94:  MOVLW  20
1B96:  MOVWF  x73
1B98:  RCALL  16D2
....................                 send_hex(le_rtc(dia));  swputc ('/'); 
1B9A:  MOVLW  04
1B9C:  MOVWF  x68
1B9E:  RCALL  16A6
1BA0:  MOVFF  01,68
1BA4:  MOVFF  01,6A
1BA8:  RCALL  16DE
1BAA:  MOVLW  2F
1BAC:  MOVWF  x73
1BAE:  RCALL  16D2
....................                 send_hex(le_rtc(mes));  swputc ('/'); 
1BB0:  MOVLW  05
1BB2:  MOVWF  x68
1BB4:  RCALL  16A6
1BB6:  MOVFF  01,68
1BBA:  MOVFF  01,6A
1BBE:  RCALL  16DE
1BC0:  MOVLW  2F
1BC2:  MOVWF  x73
1BC4:  RCALL  16D2
....................                 send_hex(le_rtc(ano)); 
1BC6:  MOVLW  06
1BC8:  MOVWF  x68
1BCA:  RCALL  16A6
1BCC:  MOVFF  01,68
1BD0:  MOVFF  01,6A
1BD4:  RCALL  16DE
....................                     } 
....................  
....................         if (flagA5){ flagA5=0; //BCD em hexadecimal representa o decimal 
1BD6:  BTFSS  1D.3
1BD8:  BRA    1C58
1BDA:  BCF    1D.3
....................                 send_hex(le_rtc(hora)); swputc (':'); 
1BDC:  MOVLW  02
1BDE:  MOVWF  x68
1BE0:  RCALL  16A6
1BE2:  MOVFF  01,68
1BE6:  MOVFF  01,6A
1BEA:  RCALL  16DE
1BEC:  MOVLW  3A
1BEE:  MOVWF  x73
1BF0:  RCALL  16D2
....................                 send_hex(le_rtc(min));  swputc (':'); 
1BF2:  MOVLW  01
1BF4:  MOVWF  x68
1BF6:  RCALL  16A6
1BF8:  MOVFF  01,68
1BFC:  MOVFF  01,6A
1C00:  RCALL  16DE
1C02:  MOVLW  3A
1C04:  MOVWF  x73
1C06:  RCALL  16D2
....................                 send_hex(le_rtc(seg));  swputc (' '); 
1C08:  CLRF   x68
1C0A:  RCALL  16A6
1C0C:  MOVFF  01,68
1C10:  MOVFF  01,6A
1C14:  RCALL  16DE
1C16:  MOVLW  20
1C18:  MOVWF  x73
1C1A:  RCALL  16D2
....................                 send_hex(le_rtc(dia));  swputc ('/'); 
1C1C:  MOVLW  04
1C1E:  MOVWF  x68
1C20:  RCALL  16A6
1C22:  MOVFF  01,68
1C26:  MOVFF  01,6A
1C2A:  RCALL  16DE
1C2C:  MOVLW  2F
1C2E:  MOVWF  x73
1C30:  RCALL  16D2
....................                 send_hex(le_rtc(mes));  swputc ('/'); 
1C32:  MOVLW  05
1C34:  MOVWF  x68
1C36:  RCALL  16A6
1C38:  MOVFF  01,68
1C3C:  MOVFF  01,6A
1C40:  RCALL  16DE
1C42:  MOVLW  2F
1C44:  MOVWF  x73
1C46:  RCALL  16D2
....................                 send_hex(le_rtc(ano)); 
1C48:  MOVLW  06
1C4A:  MOVWF  x68
1C4C:  RCALL  16A6
1C4E:  MOVFF  01,68
1C52:  MOVFF  01,6A
1C56:  RCALL  16DE
....................                       } 
....................  
....................         resultado = read_adc(); 
1C58:  BSF    FC2.1
1C5A:  BTFSC  FC2.1
1C5C:  BRA    1C5A
1C5E:  MOVFF  FC3,45
1C62:  MOVFF  FC4,46
1C66:  CLRF   47
1C68:  CLRF   48
....................         tensao_lida16 = (resultado * 5000)/1023; //Valor até 16 bits (2 bytes) 
1C6A:  MOVFF  48,6B
1C6E:  MOVFF  47,6A
1C72:  MOVFF  46,69
1C76:  MOVFF  45,68
1C7A:  CLRF   x6F
1C7C:  CLRF   x6E
1C7E:  MOVLW  13
1C80:  MOVWF  x6D
1C82:  MOVLW  88
1C84:  MOVWF  x6C
1C86:  BRA    1716
1C88:  MOVFF  03,6B
1C8C:  MOVFF  02,6A
1C90:  MOVFF  01,69
1C94:  MOVFF  00,68
1C98:  MOVFF  03,6F
1C9C:  MOVFF  02,6E
1CA0:  MOVFF  01,6D
1CA4:  MOVFF  00,6C
1CA8:  CLRF   x73
1CAA:  CLRF   x72
1CAC:  MOVLW  03
1CAE:  MOVWF  x71
1CB0:  MOVLW  FF
1CB2:  MOVWF  x70
1CB4:  CALL   1236
1CB8:  MOVFF  03,4C
1CBC:  MOVFF  02,4B
1CC0:  MOVFF  01,4A
1CC4:  MOVFF  00,49
....................         sendnum(tensao_lida16); swputc(' '); 
1CC8:  MOVFF  4A,69
1CCC:  MOVFF  49,68
1CD0:  MOVFF  4A,6B
1CD4:  MOVFF  49,6A
1CD8:  RCALL  17AE
1CDA:  MOVLW  20
1CDC:  MOVWF  x73
1CDE:  RCALL  16D2
....................  
....................         //*************************************************************************** 
....................         conv_dec_2bytes(tensao_lida16); 
1CE0:  MOVFF  4A,69
1CE4:  MOVFF  49,68
1CE8:  MOVFF  4A,6B
1CEC:  MOVFF  49,6A
1CF0:  BRA    1956
....................         posicao=2*endereco16; //endereço é o ponteiro de 16 bits (byte 1 e byte 2) 
1CF2:  BCF    FD8.0
1CF4:  RLCF   51,W
1CF6:  MOVWF  53
1CF8:  RLCF   52,W
1CFA:  MOVWF  54
....................         escreve_eeprom(0, posicao, byte2); //Byte mais significativo do int16 
1CFC:  CLRF   x6A
1CFE:  MOVFF  54,6C
1D02:  MOVFF  53,6B
1D06:  MOVFF  58,6D
1D0A:  RCALL  196C
....................         escreve_eeprom(0, posicao+1, byte1 ); //byte menos significativo do int16 
1D0C:  MOVLW  01
1D0E:  ADDWF  53,W
1D10:  MOVWF  x68
1D12:  MOVLW  00
1D14:  ADDWFC 54,W
1D16:  MOVWF  x69
1D18:  CLRF   x6A
1D1A:  MOVWF  x6C
1D1C:  MOVFF  68,6B
1D20:  MOVFF  57,6D
1D24:  RCALL  196C
....................         ++endereco16; if (endereco16>=150){endereco16=0;} //Buffer de 300 bytes posicao<300 
1D26:  INCF   51,F
1D28:  BTFSC  FD8.2
1D2A:  INCF   52,F
1D2C:  MOVF   52,F
1D2E:  BNZ   1D36
1D30:  MOVF   51,W
1D32:  SUBLW  95
1D34:  BC    1D3A
1D36:  CLRF   52
1D38:  CLRF   51
....................         //*************************************************************************** 
....................          
....................         if(input(pin_e3)==0){ //Clique no botão para ler o buffer gravado 
1D3A:  BSF    F96.3
1D3C:  BTFSC  F84.3
1D3E:  BRA    1E4C
....................             send_hex(read_eeprom(5)); //teste leitura eeprom interna 
1D40:  MOVFF  FF2,68
1D44:  BCF    FF2.7
1D46:  MOVLW  05
1D48:  MOVWF  FA9
1D4A:  BCF    FA6.6
1D4C:  BCF    FA6.7
1D4E:  BSF    FA6.0
1D50:  MOVF   FA8,W
1D52:  BTFSC  x68.7
1D54:  BSF    FF2.7
1D56:  MOVWF  x69
1D58:  MOVFF  69,6A
1D5C:  RCALL  16DE
....................  
....................          //***************LEITURA DO BUFFER DA EEPROM EXTERNA I2C******************** 
....................                 for(i=0; i<10; ++i) { //150 Valores de 16 bits ou 300 de 8 bits. 
1D5E:  CLRF   4E
1D60:  CLRF   4D
1D62:  MOVF   4E,F
1D64:  BNZ   1E3A
1D66:  MOVF   4D,W
1D68:  SUBLW  09
1D6A:  BNC   1E3A
....................                     for(j=0; j<15; ++j) { 
1D6C:  CLRF   50
1D6E:  CLRF   4F
1D70:  MOVF   50,F
1D72:  BNZ   1E20
1D74:  MOVF   4F,W
1D76:  SUBLW  0E
1D78:  BNC   1E20
....................                         valorgravado= 256*le_eeprom(0,(i*30)+2*j) + le_eeprom(0,(i*30)+2*j+1); 
1D7A:  MOVFF  4E,6E
1D7E:  MOVFF  4D,6D
1D82:  CLRF   x70
1D84:  MOVLW  1E
1D86:  MOVWF  x6F
1D88:  RCALL  19C8
1D8A:  MOVFF  02,69
1D8E:  MOVFF  01,68
1D92:  BCF    FD8.0
1D94:  RLCF   4F,W
1D96:  MOVWF  02
1D98:  RLCF   50,W
1D9A:  MOVWF  03
1D9C:  MOVF   02,W
1D9E:  ADDWF  01,W
1DA0:  MOVWF  x6A
1DA2:  MOVF   03,W
1DA4:  ADDWFC x69,W
1DA6:  MOVWF  x6B
1DA8:  CLRF   x73
1DAA:  MOVWF  x75
1DAC:  MOVFF  6A,74
1DB0:  RCALL  19E6
1DB2:  MOVFF  01,6C
1DB6:  CLRF   x6B
1DB8:  MOVFF  4E,6E
1DBC:  MOVFF  4D,6D
1DC0:  CLRF   x70
1DC2:  MOVLW  1E
1DC4:  MOVWF  x6F
1DC6:  RCALL  19C8
1DC8:  MOVFF  02,6E
1DCC:  MOVFF  01,6D
1DD0:  BCF    FD8.0
1DD2:  RLCF   4F,W
1DD4:  MOVWF  02
1DD6:  RLCF   50,W
1DD8:  MOVWF  03
1DDA:  MOVF   02,W
1DDC:  ADDWF  01,W
1DDE:  MOVWF  x6F
1DE0:  MOVF   03,W
1DE2:  ADDWFC x6E,W
1DE4:  MOVWF  x70
1DE6:  MOVLW  01
1DE8:  ADDWF  x6F,W
1DEA:  MOVWF  x71
1DEC:  MOVLW  00
1DEE:  ADDWFC x70,W
1DF0:  MOVWF  x72
1DF2:  CLRF   x73
1DF4:  MOVWF  x75
1DF6:  MOVFF  71,74
1DFA:  RCALL  19E6
1DFC:  MOVF   01,W
1DFE:  ADDWF  x6B,W
1E00:  MOVWF  55
1E02:  MOVLW  00
1E04:  ADDWFC x6C,W
1E06:  MOVWF  56
....................                         sendnum(valorgravado); swputc(' '); 
1E08:  MOVFF  56,6B
1E0C:  MOVFF  55,6A
1E10:  RCALL  17AE
1E12:  MOVLW  20
1E14:  MOVWF  x73
1E16:  RCALL  16D2
....................                                         } 
1E18:  INCF   4F,F
1E1A:  BTFSC  FD8.2
1E1C:  INCF   50,F
1E1E:  BRA    1D70
....................                         sendsw("\n\r"); 
1E20:  MOVLW  0A
1E22:  MOVWF  59
1E24:  MOVLW  0D
1E26:  MOVWF  5A
1E28:  CLRF   5B
1E2A:  CLRF   x6C
1E2C:  MOVLW  59
1E2E:  MOVWF  x6B
1E30:  RCALL  1A36
....................                                     } 
1E32:  INCF   4D,F
1E34:  BTFSC  FD8.2
1E36:  INCF   4E,F
1E38:  BRA    1D62
....................                         sendsw("\n\r"); 
1E3A:  MOVLW  0A
1E3C:  MOVWF  59
1E3E:  MOVLW  0D
1E40:  MOVWF  5A
1E42:  CLRF   5B
1E44:  CLRF   x6C
1E46:  MOVLW  59
1E48:  MOVWF  x6B
1E4A:  RCALL  1A36
....................                              } 
....................         //*************************************************************************** 
....................        
....................         ++i; if(i>255) {i=0;} 
1E4C:  INCF   4D,F
1E4E:  BTFSC  FD8.2
1E50:  INCF   4E,F
1E52:  MOVF   4E,W
1E54:  SUBLW  00
1E56:  BC    1E5C
1E58:  CLRF   4E
1E5A:  CLRF   4D
....................         write_eeprom(5, i); 
1E5C:  MOVLW  05
1E5E:  MOVWF  FA9
1E60:  MOVFF  4D,FA8
1E64:  BCF    FA6.6
1E66:  BCF    FA6.7
1E68:  BSF    FA6.2
1E6A:  MOVFF  FF2,00
1E6E:  BCF    FF2.7
1E70:  MOVLB  F
1E72:  MOVLW  55
1E74:  MOVWF  FA7
1E76:  MOVLW  AA
1E78:  MOVWF  FA7
1E7A:  BSF    FA6.1
1E7C:  BTFSC  FA6.1
1E7E:  BRA    1E7C
1E80:  BCF    FA6.2
1E82:  MOVF   00,W
1E84:  IORWF  FF2,F
....................         output_toggle(pin_b7); 
1E86:  BCF    F93.7
1E88:  BTG    F8A.7
....................         delay_ms(1000); 
1E8A:  MOVLW  04
1E8C:  MOVLB  0
1E8E:  MOVWF  x68
1E90:  MOVLW  FA
1E92:  MOVWF  x78
1E94:  CALL   1318
1E98:  DECFSZ x68,F
1E9A:  BRA    1E90
....................              } 
1E9C:  BRA    1B40
.................... } 
....................  
1E9E:  SLEEP 

Configuration Fuses:
   Word  1: 0E24   NOIESO NOFCMEN HSPLL PLL5 CPUDIV1 USBDIV
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8300   PBADEN CCP2C1 MCLR NOLPT1OSC RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
